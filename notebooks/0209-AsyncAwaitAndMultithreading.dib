#!markdown

# Async, Await, and Multithreading

As part of the .NET ecosystem, the C# language has access to all of the features of the .NET frameworks and runtime.  This allows us to have access to the threading and memory management features of the .NET runtime.  This is a great feature for writing asynchronous code.  In C#, we can use the **async** and **await** keywords to write asynchronous code.  Combined with the Task Parallel Library, this allows us to write code that is multi-threaded and supports multiple CPU cores.

## Key features of async and await:

- Async code can be used for both I/O bound and CPU bound code, but differently for each scenario
- Async code uses `Task<T>` and `Task` return types to model the work being completed in the background
- The `async` keyword turns a method into an asynchronous method, which allows you to use the `await` keyword in its body
- When the `await` keyword is used, it suspends the calling method and yields control back to its caller until the awaited task completes
- `await` can only be used inside an async method

## CPU bound vs I/O bound

1.  Will your code be "waiting" something from disk or across a network?
  
	 If yes, then your work is I/O bound

2.  Will your code be performing an expensive computation?
	
	 If yes, then your work is CPU bound

## Example 1:  Get data from the network

Let's fetch the .NET homepage from the network using the `HttpClient` class.	We'll use the `async` keyword to make this code asynchronous.  The `await` keyword is used to suspend the calling method until the awaited task completes.  While this code fetches data from the .NET website, the normal code continues to run.

#!csharp

using System.Net.Http;

private readonly HttpClient _Client = new HttpClient();

public async Task<string> GetAsync(string url)
{
	var response = await _Client.GetAsync(url);
	return await response.Content.ReadAsStringAsync();
}

display(await GetAsync("https://dot.net"));

#!markdown

### Explanation

The `Task<string>` return type indicates that this method will return a pointer to the state of the background process and it expects to return from the completed process a `string`.  On line 7, it requests the URL and awaits the response, suspending the calling method until the response is received.  On line 8, it uses the `await` keyword again to suspend the calling method while it reads the content of the response from the network.

## Example 2: Multiple Asynchronous Operations

We can shift things a little and run multiple fetch requests in parallel.  We won't `await` the methods, but instead stash the `Task` in variables.  We'll the use the `Task.WhenAll` method to wait for all of the tasks to complete.  

#!csharp

var sw = System.Diagnostics.Stopwatch.StartNew();
var bing = GetAsync("https://www.bing.com");
var dotNet = GetAsync("https://dot.net");

await Task.WhenAll(bing, dotNet);

display($"Bing HTML length: {bing.Result.Length}");
display($"DotNet HTML length: {dotNet.Result.Length}");
display(sw.ElapsedMilliseconds);

#!markdown

Let's explore the Task object a bit.  There's a but we can do there.	We can use the `Task.WhenAll` method to wait for all of the tasks to complete.  This method takes an array of `Task` objects and waits for all of them to complete.  The `Task.WhenAll` method returns a `Task<Task[]>` object.  The `Task<Task[]>` object is a pointer to the state of the background process and it expects to return from the completed process an array of `Task` objects.  

We can also use the `Task` object to continue and run other methods when it completes.  We'll use the `ContinueWith` method to run a method when the `Task` completes.  The `ContinueWith` method takes a method that will run when the `Task` completes.  The `ContinueWith` method returns a `Task` object.  The `Task` object is a pointer to the state of the background process and it expects to return from the completed process a `Task` object. 

#!csharp

var dotNet = GetAsync("https://dot.net").ContinueWith(task =>
{
	display(task.IsCompleted);
	display($"DotNet HTML length: {task.Result.Length}");
});

display($"Checking dotNet complete state: {dotNet.IsCompleted}");
await dotNet;
